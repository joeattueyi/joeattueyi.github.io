{"name":"why joe? seriously, why?","tagline":"jattueyi@gmail.com","body":"***\r\n\r\n```\r\nvar l = function(){\r\n    console.log.apply(null, ([].slice.call(arguments)))\r\n}\r\n\r\nvar gen_id = function(){\r\n    return Date.now() + Math.random(Math.random() * 10000000);\r\n}\r\n\r\n\r\nfunction fibre(){\r\n\r\n    return {id: gen_id(), context: {}, active: false, body: null};\r\n}\r\n\r\n\r\nfunction lib_fibre(){\r\n    var fibre_q = {};\r\n    \r\n\r\n    return{\r\n        gen_id : function(){\r\n            return Math.floor(Math.random() * 10000000);\r\n        },\r\n        spawn: function(fn){\r\n            _f = fibre();\r\n            _f.body = fn();\r\n            fibre_q[_f.id] = _f;\r\n        },\r\n\r\n        go: function(){\r\n            while (Object.keys(fibre_q).length > 0){\r\n                //l(fibre_q);\r\n                for(var v in fibre_q){\r\n                    //l(v , fibre_q[v] );\r\n                    var fn = fibre_q[v].body;\r\n                    //l(fn);\r\n                    var ref = fn.next();\r\n                    //l(ref);\r\n\r\n                    if(ref.done){ \r\n                        //l(\"in delete\"); \r\n                        delete fibre_q[v];\r\n                    }\r\n                    //fibre_q[v].body = fn.next;\r\n\r\n                }\r\n            } \r\n        },\r\n    };\r\n}\r\n   \r\n\r\nvar lf = lib_fibre();\r\n\r\nvar a = function *(){\r\n    yield l(\"Hi\");\r\n    yield l(\"Joe\");\r\n    yield l(\"Welcome\");\r\n    yield l(\"!!!!!!\");\r\n}\r\nvar b = function *(){\r\n    var x = 10;\r\n\r\n    while (x > 0){\r\n        yield l(x);\r\n        x -= 1;\r\n    }\r\n}\r\nvar c = function *(){\r\n    yield l(\"END\");\r\n}\r\n\r\nlf.spawn(c);\r\n\r\nlf.spawn(a);\r\n\r\nlf.spawn(b);\r\nlf.go();\r\n\r\n\r\n\r\n```\r\n\r\n***\r\n***\r\n### I WROTE A LISP\r\n\r\nA few weeks ago, i spent some time writing a Lisp in Javascript. This was due to having enjoyed writing Clojure and researching Lisps in general. I watched a few of the SICP lectures online and read Peter Norvig's [How to Write a Lisp Interpreter in Python](http://norvig.com/lispy.html) for some pointers and went on my way.\r\n\r\nThe lisp which I've imaginatively named Joelisp is a bit different to standard Lisps in terms of syntax as it inherits a lot of Clojure syntax and also uses [mori's](https://github.com/swannodette/mori) data structures. \r\n\r\nIt differs from most Lisps in that I have special semantics for evaluating code in depth first order. Code wrapped in an rx function will figure out the implicit dependency graph in your code and will run your code in topologically sorted order.\r\n\r\nThis kind of feature would be useful for doing reactive programming as it ensures that the values in variables propagate through the whole program even after the variable is mutated. \r\n\r\nIt also lets you make forward declarations on variables that don't exist yet which is pretty handy.\r\n\r\nAn example use of the rx tag is\r\n\r\n```\r\n(rx \r\n    (def c (+ a b))\r\n    (def d (* a b c))\r\n    (def b (+ a 1))\r\n    (def a 1)\r\n    (set! a 100)\r\n   )\r\n\r\n(print a)\r\n(print b)\r\n(print c)\r\n(print d)\r\n\r\n```\r\n\r\nreturns you \r\n\r\n```\r\n100\r\n101\r\n201\r\n2030100\r\n```\r\n\r\npretty cool huh!\r\n\r\n***\r\n\r\n***\r\n### HE'S BACK\r\n```\r\n$ say \"why joe???\"\r\n```\r\n\r\nI'm coming out of blogging retirement trying to relive the glory days of the late 00s/early 10s. I can hear u asking why anyone would want to do that, and i'm not sure why either but hopefully we can find out together.\r\n\r\nTil next time \r\n***","google":"UA-46776176-1","note":"Don't delete this file! It's used internally to help with page regeneration."}